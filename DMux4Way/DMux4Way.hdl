/**
 * 4-way demultiplexor.
 * {a,b,c,d} = {in,0,0,0} if sel==00
 *             {0,in,0,0} if sel==01
 *             {0,0,in,0} if sel==10
 *             {0,0,0,in} if sel==11
 */

CHIP DMux4Way {
    IN in, sel[2];
    OUT a, b, c, d;

    PARTS:
    // NOT gates
    Nand(a=sel[0], b=sel[0], out=notSel0);
    Nand(a=sel[1], b=sel[1], out=notSel1);

    // First level DMux
    Nand(a=in, b=notSel1, out=temp1);
    Nand(a=temp1, b=temp1, out=outAB);
    Nand(a=in, b=sel[1], out=temp2);
    Nand(a=temp2, b=temp2, out=outCD);

    // Second level DMux for AB
    Nand(a=outAB, b=notSel0, out=temp3);
    Nand(a=temp3, b=temp3, out=a);
    Nand(a=outAB, b=sel[0], out=temp4);
    Nand(a=temp4, b=temp4, out=b);

    // Second level DMux for CD
    Nand(a=outCD, b=notSel0, out=temp5);
    Nand(a=temp5, b=temp5, out=c);
    Nand(a=outCD, b=sel[0], out=temp6);
    Nand(a=temp6, b=temp6, out=d);
}



// Alternate implementation, using a canonical representation.
/*
    Not (in=sel[0], out=notSel0);
    Not (in=sel[1], out=notSel1);
    And (a=notSel1, b=notSel0, out=selA);
    And (a=notSel1, b=sel[0],  out=selB);
    And (a=sel[1],  b=notSel0, out=selC);
    And (a=sel[1],  b=sel[0],  out=selD);
    And (a=selA, b=in, out=a);
    And (a=selB, b=in, out=b);
    And (a=selC, b=in, out=c);
    And (a=selD, b=in, out=d);
*/
